# This is Arkanoid

# ПЕРВАЯ ИТЕРАЦИЯ АРКАНОИДА

# 1. Техническая часть
Большая часть опирается на библиотеку Pygame. На ней основаны:
      - обновление экрана
      - рисование 
      - геометрические объекты (шарик, прямоугольник)
      - ... и их показатели (ширина, длина, начальное положение)

# 2. Код
Разбит на несколько этапов
      1) импорты 
          - Собственно сам pygame и генератор псевдослучайных чисел для раскраски наших блоков, а также начального положения мячика.
      2) настройки интерфейса
          - экран 1850/1000 Странное число, но стандартный full hd не помещался в мой монитор, а маленький размер резал картинку
          - параметры платформы длина, ширина, расположение на экране, скорость перемещения
          - параметры мячика радиус, скорость *интересная идея для реализации это вписать в шарик квадрат, чтобы просчитывать столкновения со сторонами окна и блоками, признаюсь в её похищении* расположение в начале игры определяем случайно, также задаем две дельты по координатам x, y чтобы считать направление =>> столкновения
          - настройки блоков (изначально красятся случайными цветами и расставляются в виде сетки 15 на 5) В формулировке сказано, что пользователь может расставлять блоки, однако я пока не могу понять, расставлять на произвольные места на поле или выбирать какие ячейки занимать, можно ли ставить блоки друг на друга и т.д. поэтому сейчас просто как пример стоят так4
          - прекрасные картинки фона, победы и поражения. На данный момент обновление экрана происходит в цикле while true поэтому обновить картинку получается только в ходе игры *что конечно неплохо, но хотелось бы видеть you win, когда это правда* для этого нужно повисеть в меню игры хотя бы немного до выхода
      3) контроллеры
          - левая и правая кнопка мыши при нажатии двигают влево и вправо соответственно со скоростью платформы
      4) Обновление экрана 
          - я использую display.flip, рассматривала update, но прочитала что flip обновляет весь экран в то время как update только делает это по умолчанию, если не передавать аргумент. Как здорово для фона, наверное, но нет, он же все равно не обновился в конце игры. Не вышло получается. 
          - clock.tick с частотой кадров fps (60 - default). Частота смены кадров также задействована в управлении скоростью мячика. Были попытки просто увеличивать смещение - материальную скорость. но тогда появлялись "проскакивания" на высоких уровнях, расстояние между положениями было слишком заметным.
      5) Алгоритмы
          - о них пожалуй отдельно...

# Алгоритмы
Главные алгоритмы - столкновения мяча с объектами во всех проявлениях.
    - мяч отскакивает согласно законам физики, угол падения = углу отражения, т.к. из-за этого у него нет на это пяти причин (да и одной нет) чтобы изменить свою величину, угол всегда 45 градусов.
    - движение мяча довольно простое - скорость на направление
    
    Столкновения заслуживают отдельного внимания
        1) со стеной
            - сравниваем координату центра мяча с разницей между координатами сторон окна. Если меньше радиуса - меняем направление мяча на противоположное (по координате столкновения)
        2) с платформой (с прямоугольником) 
            - стены от нас никуда не денутся, а платформа - вещь сложная, поэтому используем методы pygame чтобы определить, что наш прямоугольник платформы касется вписанного в мяч квадрата. Сравнивать с нулем некрасиво поэтому заведем маленькие дельты, чтобы отслеживать вертикальное/горизонтальное расстояние блоков друг от друга и менять направление в связи с этим
        3) с блоками
            - снова используем методы pygame, а именно collidelist и просто удаляем блок если он есть в списке столкноений, делаем удаление из списка цветов и блоков, а столкновение считаем как для обычных прямоугольников в том числе платформы


# Планы
Мне ещё предстоит
    - сделать счет
    - настройки расстановки платформ (скорее всего через зажатие мыши, на каком либо месте экрана)
    - меню победы/поражения

